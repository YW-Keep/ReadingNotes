###  Effective Objective-C2.0

#### 熟悉Objective-C

##### 1.了解Objective-C的起源

OC与C最大的区别是C函数调用编译时就已决定所调用的函数OC是消息结构由运行环境来决定的。

Objective-C为C语言添加了面向对象特性，是其超集。Objective-C使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器决定。

**Objective-C的指针以及一些非对象类型（int,float,double,char等）分配在栈上，对象分配在堆上。**

**分配在堆中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时自动清理。**

##### 2.在类的头文件中尽量少引入其他头文件

如果可以用向前声明取代引入，那么就不要引入。但是继承与协议这类必须引入头文件的则引入。如果是协议这种情况尽量移至"class-continuation分类"中，如果不行，则把协议单独放在一个头文件中，然后将其引入。

##### 3.多用字面量语法，少用与之等价的方法

字面量语法简单，也更为安全。

##### 4.多用类型常量，少用#define预处理指令

**若常量局限于某“编译单元”（也就是“实现文件”）之内，则前面加字母k，若常量在类之外可见，则通常以类名为前缀。**

类型常量一定要同时使用static和const修饰，其中const表示是个常量不能被修改，而static表示只在定义变量的编译单元中可见，如果不加static则为全局的。如果需要外部使用，比如通知，则需要用extern 

```objective-c
// In the header file
extern NSString *const EOCStringConstant;
// In the implementation file
NSString *const EOCStringConstant = @"VALUE"
```

常量定义应从右至左读解，所以这里EOCStringConstant就是“一个常量，而这个常量是指针，指向NSString对象”

extern 表示告诉编译器，在全局符号表中将会有一个名叫EOCStringConstant的符号

##### 5.用枚举表示状态、选项、状态码

凡是需要以按位或操作来组合的枚举都应使用NS_OPTIONS定义，若是枚举不需要互相组合，则应使用NS_ENUM来定义。

#### 对象、消息、运行时

“对象（object）”是基本构造单元，开发者可以通过对象来存储并传递数据。在对象之间传递数据并执行任务的过程叫做“消息传递”。

##### 6.理解“属性”这一概念

如果代码使用了编译期计算出来的偏移量，那么在修改类的定义，为类增加新的实例变量时，则需要重新编译计算偏移量（实例变量的位置就是对象位置偏移多少所得到的）。**Objective-C的做法是，把实例变量当做一种存储偏移量所有的“特殊变量”交由“类对象”保管。**这样做的好处就是偏移量会在运行时查找，所以无论何时访问实例变量，总能使用正确的偏移量。这就是稳固的"应用程序二进制接口"（Application Binary Interface,ABI）。

这里要简单讲下**属性与实例变量的区别**

成员变量写法：

```objective-c
@public
   NSString *_name;
@private
   NSString *_time;
```

主要有四个修饰符修饰它的权限级别：

1.@public表示任何地方都能直接访问成员变量。

2.@private表示只能在当前类的对象方法中直接访问，如果子类需要访问需要调用父类的get/set方法。

3.@protected:可以在当前类及其子类对象方法中直接访问(系统默认下是用它来修饰的)

4.@package:在同一个包下就可以直接访问，比如说在同一个框架。（做第三方SDK时候用的比较多）

注意2个点：

无论是.h还是.m中声明的成员变量，子类都拥有，但是是否能访问则要看修饰符了。

默认在.m中的实例变量修饰符是private，而在.h中的修饰符是protected。

**属性最终是通过实例变量实现的，就是在编译阶段生成相应的实例变量以及set，get方法，当然如果实例变量存在则不生成了**

属性的特点就是编译器会自动写出一套存取方法，用以访问给定类型中居右给定名称的变量。

```objective-c
@property (nonatomic,readwrite,copy) NSString *name;
```

可以使用@synthesize指定变量名字。

也可以使用@dynamic告诉编译器不要自动创建实现属所用的实例变量，也不要为其创建存取方法。

##### 属性特质（决定了属性的特性（例如是否能存取等等）），有四类：

1.原子性：nonatomic，atomic表示其是否使用同步锁，使用**同步锁能保证存取安全(不保证线程安全)**，但是会大大增加其性能损耗，所以一般用nonatomic，虽然默认的是atomic。

2.读/写权限： readwrite,readonly(只读和读写)，当该属性由@synthesize实现时，编译器才会为其合成获取方法。 

3.内存管理语义：

assign:只针对纯量类型（例如NSInteger, CGFloat）

strong:设置方法会先保留新值，并释放旧值，然后再讲新值设置上去。

weak:对象销毁后会自动设置nil

unsafe_unretained copy:对象销毁后不会自动设置成nil，与assign有点类似表示不持有

copy:与strong类似但是不保留新值而是拷贝。

4.方法名：getter=<name>,setter=<name>这种方式修改。

##### 7.在对象内部尽量直接访问实例变量

对象外访问时。应该通过属性来做。

直接访问成员变量有有以下要点：

1.不进过Objective-C的"方法派发"所以直接访问实例变量的速度快。

2.会绕过设置方法，copy属性也就无效了。

3.不触发KVO键值观察。

所以一般相对来说比较好的方案是**读直接访问，写通过属性方法**。

当然也不绝对，懒加载就需要属性方法来触发它。

##### 8.理解“对象等同性”这一概念

Objective-C在编译期不做强类型检查，所以开发者应尽力保证所传对象正确。

想要检测对象的等同性，则需要重写"isEqual:"与hash方法。默认方法为==判断，即只校验你指针是否相等。

**相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象未必相同。**

这里可简单的讲下collection（set）的实现，其实collection会把各个对象按照其哈希吗分装到不同的“箱子数组”中。也就是说两个对象哈希码相同是放在一个数组里的。当需要找一个对象的时候先通过哈希码进行查找数组的。

所以说我们在实现hash方法的时候要注意两点：

1.应该使用计算速度快且哈希码碰撞几率低的算法。

2.对象尽量是不可变的来确保哈希码不变。

最后不要盲目的去逐条检查属性来判等，应该根据需求来做相应的方案。（其他方案也有比如增加唯一标识符等等）

##### 9.以“类族模式”隐藏实现

类族模式可以把实现细节隐藏在一套简单的公共接口后面。

##### 10.在既有类中使用关联对象存放自定义数据

可以通过“关联对象”机制来把两个对象关联起来，定义关联对象时可以指定内存管理语义，用以模仿定义属性时所采用的"拥有关系"与"非拥有关系"。

**只有在其他做法不可行时才应用关联对象，因为这种做法通常会引入难于查找的bug。**

##### 11.理解objc_msgSend

Objective-C的方法调用其实都是给对象发送消息，调用的C语言函数为objc_msgSend。

如果某函数的最后一项操作是调用另外一个函数，那么久可以运用"尾调用优化"技术，即编译器会生成跳转至另一个函数所需的指令，而且不会向调用堆栈中推入新的”栈帧“。

消息由接受者、选择子及参数构成。给某对象发送消息也就相当于在该对象上调用方法。

发给某对象的全部消息都要由”动态消息派发系统“来处理，该系统会查出对应的方法，并执行其代码。

##### 12.消息转发机制

消息转发分为两个阶段：第一阶段征询接受者，所属的类，看其是否能动态添加方法，以处理当前这个”未知的选择器子“，即**动态方法解析**。第二阶段：如果第一阶段执行完了，首先看看有没有其他对象能处理这个消息，如果有则转发给它，如果没有则启动完整的消息转发机制：即把消息封装到NSInvocation中，然后触发该对象时，把消息指派给目标对象。

**接受者在每一步均有机会处理消息，步骤越往后，处理消息的代价就越大。**

##### 13.用“方法调配技术”调试黑盒方法

类的方法列表会把选择子的名称映射到相关的方法实现智商，使得“动态消息派发系统”能够根据此找到应该调用的方法。这些方法均已函数指针的形式来表示，这种指针叫做IMP。

```objective-c
id (*IMP)(is,SEL,....)
```

在运行期，可以向类中新增或者替换选择子所对应的方法实现。除非万不得已尽量不要使用该方法，会引起方法混乱。

##### 14.理解“类对象”的用意

每个类仅有一个类对象（存放实例方法）每个类对象仅有一个元类（存放类方法）

![](https://raw.githubusercontent.com/YW-Keep/ReadingNotes/master/image/runtime/superclass%E4%B8%8Eisa.png)

isMemberOfClass：能够判断出对象是否为某个特定类的实例。而isKindOfClass：则能判断对象是否为某类或其派生类的实例。（通过isa指针做到的）

如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发。（通过信息查询方式是可以实现消息转发的）。

#### 接口与API设计

##### 15.用前缀避免命名空间冲突

Apple宣称其保留使用所有“两个字母前缀”的权利。

分类以及其方法名最好加前缀防止编译覆盖冲突等问题。

##### 16.提供”全能初始化方法“

全能初始化方法为：可为对象提供必要信息以便其能完成工作的初始化方法。

若全能初始化方法与超类不同，则需覆写超类中的对应方法，如果超类的初始化方法不适合子类，则应该复写超类中的方法抛出异常。

##### 17.实现description方法

实现description返回一个字符串，可以在Log打印时看到它，而debugDescription则在控制台用po 命令打印时可以看到。

##### 18.尽量使用不可变对象

若某属性仅可于对象内部修改，则在"class-contination分类"中将其由readonly属性扩展为readwrite。

不要把可变的collection作为公开属性，而应提供相关方法，以此修改对象中的可变collection。

##### 19.使用清晰而协调的命名方式

起名时应遵从标准的Objective-C命名规范，这样创建出来的接口更容易为开发者所理解。

##### 20.为私有方法名家前缀

这种方式很容一把公关方法和私有方法区别开。

一般私有方法以下划线为开头来区分，苹果也是这么做的所以要小心复写苹果的方法，最好加个前缀。

##### 21.理解Objective-C错误模型

只在极其罕见的情况下抛出异常，异常抛出之后，无需考虑恢复问题，而且应用程序此时也应该退出。

不严重时用nil/0，或者NSError处理。

##### 22.理解NSCopying协议

想要自己的类支持拷贝操作，需要实现NSCopying协议，协议只有一个方法：

```objective-c
- (id)copyWithZone:(NSZone *)zone
```

不要假定遵从了NSCopying协议的对象都会执行深拷贝，绝大多数情况下，执行的都是浅拷贝。

#### 协议与分类

##### 23.通过委托与数据源协议进行对象间通信

委托模式：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”。此模式可将数据与业务逻辑解耦。

委托模式为对象提供了一套接口，使其可由此相关事件告知其他对象。将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。

当某对象需要从另外一个对象中获取数据时，也可以使用委托模式，这种情况下该模式又叫“数据源协议”

若有必要，可以实现含有段位的结构体，将委托对象是否能相应相关协议方法这一信息缓存起来。

##### 24.将类的实现代码分散到便于管理的数个分类中。

使用分类机制把类的实现代码划分成易于管理的小块。

可能会遇到这样一些方法：它们不是公共API的一部分，然而却非常适合在程序库内使用。此时可以创建私有的分类，这个头文件不公开，在库内想要使用的地方引入头文件即可。

##### 25.总是为第三方类的分类名称加前缀

因为分类是给类增加方法，所以当不同分类中的方法名称相同是，会引起覆盖的情况，谁最后加载会把前面的重名方法覆盖（其实方法是一个链表，分类添加方法越后面加载的就排在越在前面，方法调用时就最先被找到，这样后面的方法等于就是被覆盖了。）。所以说需要**以命名空间为前缀放在分类方法名，分类名之前。**

##### 26.勿在分类中声明属性

分类中可以声明属性，但是这种做法应该尽量避免，因为**除了"class-continuation分类"之外，其他分类都无法向类中新增实例变量，因此，他们无法把实现属性所需的实例变量合成出来。**

当然你真的需要加，可以通过关联方法实现存取。

还有一种情况是可以使用分类声明属性，就是计算属性（把属性设置成只读，然后完成读取）。

##### 27.使用”class-continuation分类“隐藏实现细节

用”class-continuation分类“，可以隐藏实现，而且在Objective-C与C++混合开发时候隐藏C++实现，给出一个干净的.h。

”class-continuation分类“还有一种合理用法，就是将public接口中声明为只读的属性扩展为”可读写“，以便在类的内部设置其值。

若对象所遵从的协议只应视为私有，则可在“class-continuation分类”中声明。

##### 28.通过协议提供匿名对象

协议可以在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的id类型，协议里规定了对象所实现的方法。如果具体类型不重要，重要的是对象能工相应（定义在协议里的）特定方法，那么可使用匿名对象来表示。

#### 内存管理

##### 29.理解引用计数器

引用计数机制通过可以递增递减的计数器来管理内存，对象创建好之后，其保留计数至少为1，若保留计数为正，则对象存活，当保留计数降为0时，对象就被销毁了。

##### 30.以ARC简化引用计数器

ARC管理对象生命期的办法基本上就是：在合适的地方插入“保留”及“释放”操作。在ARC环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行“保留”及“释放”操作。

##### 31.在dealloc方法中只释放引用并解除监听

在dealloc方法里，应该做的事情是释放指向其他对象的引用（CF等需要手动释放的），并取消原来订阅的“键值观察，KVO”或NSNotificationCenter等通知，不要做其他事情。因为对象已处于正在回收状态了，尤其不要再调用异步任务了。

##### 32.编写“异常安全代码”时留意内存管理问题

捕获异常时，一定要注意将try块内所创立的对象清理干净。

在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后（-fobjec-arc-exceptions）可以生成这种代码，不过会导致应用程序变大，而且会降低运行效率。

##### 33.以弱引用避免保留环

将某些引用设为weak,可避免出线“保留环”。

##### 34.以“自动释放池块”降低内存峰值

是否应该用池来优化效率，完全取决于具体的应用程序。首先得监控内存用量，判断其中有没有需要解决的问题，如果没有完成这一步，那就别着急优化。尽管自动释放池的开销不太大，但是还是有的，所以尽量不要建立额外的自动释放池。

##### 35.用“僵尸对象”调试内存管理问题

启动“僵尸对象”调试后，运行期系统会把所有已经回收的实例转化成特殊的“僵尸对象”，而不会真正回收他们。这种对象所在的核心内存无法重用，因此不可能遭到腹泻。僵尸对象收到消息后，会抛出异常，其中准确说明了发送过来的消息，并描述了回收之前的那个对象。

将NSZombieEnabled环境变量设置为YES,即可开启“僵尸对象”调试。

系统会修改对象的isa指针，令起指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够相应所有的选择子，相应方式为：打印一条包含消息内容以及接受者的消息，然后终止应用程序。

##### 36.不要使用retainCount

首先这个值没有意义，只代表某个点的计数数量，其次ARC下使用已经会报错了。

####  block与GCD

##### 37.理解“块”这一概念

block的本质就是对象。

块可以分配在栈或堆上分配在栈上的块可以拷贝到堆里，这样的话就和标准的Objective-C对象一样，具备引用计数了。

##### 38.为常用的块类型创建typedef

使用类型不仅使参数看起来容易看了，而且还有个好处就是当你打算重构块的类型签名时会方便很多。

##### 39.用handler块降低代码分散程度

在创建对象时，可以使用内敛的handler块将相关业务逻辑一并声明。

设计API时如果用到了handler块，那么可以增加一个参数，使调用者可以通过此参数啦决定应该把块安排在哪个队列上执行。

##### 40.用块引用起所属对象时不要出现保留环

如果块所捕获的对象直接或间接的保留了块本身，那么就得当心保留环的问题。

##### 41.多用派发队列，少用同步锁

派发队列可以用来表述同步语义，这种做法要比使用@synchronize块或者NSLock对象更简单。

同步取是正常的，但是是否需要异步存就要考虑你的block内的内容是否大了 如果大可以异步存，而小的话其实拷贝也需要时间可能还是同步比较快捷。

可以通过同步并发取，而栅栏块取的方式实现锁的效果，更加高效易用。

##### 42.多用GCD,少用performSelector系列方法

performSelector系列方法在内存管理方面容易有问题，因为它无法确定将要执行的选择子具体是什么，因而ARC编译器也就无法插入适当的内存管理方法。

performSelector系列方法所能处理的选择子太过局限了，选择子的返回值类型以及发送给方法的参数个数都受到限制。

如果想把任务放在另一个线程上执行，最好也别用performSelector,用GCD比较好。

##### 43.掌握GCD及操作队列的使用机制

操作队列（NSOPerationQueue以及NSOperation）提供了一套高层的Objective-C API，能实现纯GCD所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若使用GCD,则需另外编写代码。

##### 44.通过Dispatch Group机制，根据系统资源状况来执行任务

一系列任务可归入一个dispatch group之中。开发者可以在这组任务执行完毕时获得通知。

通过dispatch group，可以在并发式派发队列里同时执行多项任务，此时GCD会根据系统资源状况来调度这些并发执行的任务，如果开发自己来实现此功能，需要编写大量代码。

##### 45.使用dispatch_once来执行只需运行一次的线程安全代码

传入的标记应该声明在static或global作用域中，这样的话，在把只需执行一次的块传给dispatch_once函数时，传进去的标记也是相同的。

##### 46.不要使用dispatch_get_current_queue

GCD提供一个功能来设定“队列特有数据”，此功能可以把任意数据以键值对的形式关联到队列里，最重要之处在于，假如根据指定的键获取不到关联数据，那么系统就回沿着层级体系向上查找，直到找到数据或直达根队列为止，通过这种方式我们可以鉴别到底在什么队列中。

dispatch_get_current_queue这个方法已经被废弃了，而且判断当前队列不能解决重复如入队列引起的死锁问题。

#### 系统框架

##### 47.熟悉系统框架

许多系统框架都可以直接使用，其中最重要的是Foundation和CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能。

##### 48.多用块枚举，少用for循环

块枚举拥有其他遍历方式都具备的优势，而且还能带来更多好处，与快速遍历相比，它要多用一些代码，可是却能提供遍历时所针对的下标，在遍历字典时也能同时提供键与值，而且还有选项可以开启并发迭代功能，所以多写点代码还是值得的。

##### 49.对自定义其内存管理语义的collection使用无缝桥接

在CoreFoundation层面创建collection，可以指定许多回调函数，这些函数表示此collection应如何处理其元素。然后，可以运用无缝桥接技术，将其转化成具备特殊内存管理语义的Objective-C collection。

##### 50.构建缓存时选用NSCache而非NSDictionary

NSCache胜过NSDictionary之处在于，当系统资源将要耗尽时，它可以自动删除缓存。如果采用普通的字典，那么就要自己编写挂钩，在系统发出“低内存”通知时手动删减缓存。而且NSCache是线程安全的。

将NSPurgeableDate与NSCache搭配使用，可实现自动清除数据的功能，也就是说当NSPurgeableDate对象所占内存为系统所丢弃时，该对象自身也会从缓存中移除。

如果缓存使用得当，那么应用程序的响应速度就能提高。只有那种“重新计算起来很费事的”数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。

##### 51.精简initialize与load的实现代码

```objective-c
+(void)load
```

对于加入运行期系统中的每个类及分类来说，必定会调用此方法，而且仅调用一次。当包含类或分类的程序库载入系统时，就会执行此方法，而这统称就是指应用程序启动的时候。

load方法务必实现得精简一些，也就是要尽量减少其所执行的操作，因为整个应用程序在执行load方法时都会堵塞。

类的loa方法要比分类中的先用调用，与其他方法不同，load方法不参与覆写机制。

**这里要另外说明一下load方法里是可以调用其他类的创建和方法的，因为调用load方法时候类已经导入了，但是不是很推荐的原因是，可能你调用的类load方法没有加载，这样会有个一个问题，那就是如果这个类在load方法里进行了方法替换那么如果你正好调用了替换的方法则调用是有问题的。**

```objective-c
+(void)initialize
```

对于每个类来说，该方法会在程序首次调用该类之前调用，而且只调用一次。它是由运行期系统来调用的，绝不应该通过代码直接调用。

它与load的区别是：
1.他是惰性调用，也就是说，只有当程序用到了相关的类时才会调用。

2.只有执行initialize的那个线程可以操作类或类实例，其他线程都要先堵塞，等待initialize执行完。

3.initialize与其他消息一样如果某个类未实现则会调用超类的，load不会。

无法在编译期设定的全局常量，可以放在initalize方法里初始化。

##### 52.别忘了NSTimer会保留其目标对象

1.NSTimer对象会保留其目标，直到计时器本身失效位置，调用invalidate方法可令计时器失效，另外一次性的计时器在触发完任务之后也会失效。

2.所以反复执行的计时器任务很容易引入保留环，可以用“块”来打破保留环。