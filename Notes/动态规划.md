 动态规划

### 引例：

有一座楼梯，台阶数为3， 如果一个人只能走一步或者2步，有几种走法，如果台阶数为10呢，如果台阶数为100呢？



### 建模：

其实回头想想，我们会发现 比如我们要走到台阶数为10的地方，其实就两种走法，一种是从台阶数为9的地方走一步，一种是从台阶数为8的地方走一步,也就是说f(10) = f(9) + f(8)

从上面可以看出F(1)=1，F(2)=2 

**动态规划主要包含三个要素 1.最优子结构2.边界3.状态转移方程**

从上面可以定义下 这三个概念 其中 F(9)和F(8)是f(10)的最优子结构

而F(1)与F(2)是问题的边界，如果没有边界是解不出来的

f(n) = f(n-1) + f(n-2)就状态转移方程，这个就是动态规划的核心了，即每一个阶段和下一阶段的关系。

### 求解问题：

通过上面的建模可能很容易就想到代码的写法：

```SWIFT
func getWays(_ count: Int) -> Int {
    guard count > 0 else {
        return 0
    }
    if count == 1 { return 1 }
    if count == 2 { return 2 }
    return getWays(count - 1) + getWays(count - 2)
}
```

想想这个算法的事件复杂度（2的（n-2）次方），想想是不是不是很合理，其实有很多重复计算的东西。那么怎么去做优化呢？ 备忘录

```swift
func getWays2(_ count: Int) -> Int {
    guard count > 0 else {
        return 0
    }
    var reslut = Array(repeating: 0, count: count)
    return cycle(count, &reslut)
}

func cycle(_ count: Int,_ record: inout [Int]) -> Int {
    guard count > 0 else {
        return 0
    }
    if count == 1 { return 1 }
    if count == 2 { return 2 }
    if record[count] > 0 {
        return record[count]
    } else {
        let num = cycle(count - 1, &record) + cycle(count - 2, &record)
        record[count] = num
        return num
    }
}
```

这样 时间复杂度就为N了 ，但是另外一个问题随之而来，那就是空间复杂度变为了N

再想想有什么办法可以优化呢？我们不妨把思维逆转过来。

```swift
func getWays(_ count: Int) -> Int {
    guard count > 0 else {
        return 0
    }
    if count == 1 { return 1 }
    if count == 2 { return 2 }
    var a = 1
    var b = 2
    var result = 0
    for _ in 3...count {
        result = a + b
        a = b
        b = result
    }
    return result
}

```

### 例题1- LeetCode121

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```

**示例 2:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

```swift
// 解答
class Solution {
    func maxProfit(_ prices: [Int]) -> Int {
        var maxProfit = 0
        var min = Int.max
        for num in prices {
            if num > min {
                maxProfit = max(maxProfit, num - min)
            } else {
                min = num
            }
        }
        return maxProfit
    }
}
```

### 例题2- LeetCode78 

给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）。

**说明：**解集不能包含重复的子集。

**示例:**

```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

```swift
class Solution {
    func subsets(_ nums: [Int]) -> [[Int]] {
        var result: [[Int]] = [[]]
        for num in nums {
            result = result.map({ (index) -> [Int] in
                return index + [num]
            }) + [[num],[]]
        }
        return result
    }
}
```

### 思考题- LeetCode 309

给定一个整数数组，其中第 *i* 个元素代表了第 *i* 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**示例:**

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

思路 动态规划的时候需要考虑三种状态 s0休息期（冷冻的） s1买入期 s2卖出期 



### 聊聊多维度的动态规划

