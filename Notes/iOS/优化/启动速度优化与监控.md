### 启动速度优化与监控

我们可以把APP的启动分为三个阶段：

####1.main()函数执行前

1.加载可执行文件（App的.o文件的集合）2.加载动态连接库，进行rebase指针调整和bind符号绑定。3.加载Objc运行时的初始处理，包括Objc相关类的注册，category注册，selector唯一性检查等。4.初始化，包括了执行+load()方法，attribute((constructor))修饰的函数的调用，创建C++静态全局变量。

从上面我们就可以罗列几个优化建议：

1.减少动态库的数量。当动态库多的时候，可以进行动态库合并，数量上苹果最多支持6个非系统动态库的合并。

2.减少启动后不会使用的类或方法。

3.+load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。（注意+initialize调用时机是第一次使用该类，而且会优先调用父类，当子类未实现时会调用父类方法。所以该方法可能会调用多次）

4.控制C++全局变量的数量。

#### 2.mian()函数执行后

main() 函数执行后的阶段，指的是从 main() 函数执行开始，到 appDelegate 的 didFinishLaunchingWithOptions 方法里首屏渲染相关方法执行完成。通俗的说应该是从main函数执行，到设置self.window.rootViewController。

首页的业务代码都是要在这个阶段执行的。但不应该把所有的初始化工作都放在这个阶段执行，导致渲染滞后。

所以针对这块优化就是梳理调用初始化的逻辑。这里还可以做一些减少主线程运行的优化，比如说页面的异步渲染（如果图片多的话）复杂的数据计算缓存等等。

#### 3.首屏渲染完成后

这个阶段就是从渲染完成时开始，到 didFinishLaunchingWithOptions 方法作用域结束时结束。（这个阶段就是非首屏渲染的其他服务模块初始化）

这里的话，因为用户已经看到UI了 所以卡顿太久也不好，最好的优化方式还是优化主线程执行的任务，把一些能放到异步去的任务放到异步去完成。同时还可以去检测耗时方法从而做针对性的优化。

然后我们就需要检测方法耗时了这里有两种方法：

第一种方法是，定时一般用（0.01比较好）抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时。(BSBacktraceLogger)

第二种方法是，对 objc_msgSend 方法进行 hook 来掌握所有方法的执行耗时。（具体的说，就是用fishhook hook objc_msgSend方法，然后自己实现汇编方法，方法里开始执行一个方法记录时间，然后执行objc_msgSend原方法，在执行一个方法，算出执行过程的时间做输出即可。）

最后一个比较火的二进制混排，大概实现的原理是：

Page Fault
进程如果能直接访问物理内存无疑是很不安全的，所以操作系统在物理内存的上又建立了一层虚拟内存。为了提高效率和方便管理，又对虚拟内存和物理内存又进行分页（Page）。当进程访问一个虚拟内存Page而对应的物理内存却不存在时，会触发一次缺页中断（Page Fault），分配物理内存，有需要的话会从磁盘mmap读人数据。通过App Store渠道分发的App，Page Fault还会进行签名验证，所以一次Page Fault的耗时比想象的要多。（重排目的就是减少启动时的Page Fault）

