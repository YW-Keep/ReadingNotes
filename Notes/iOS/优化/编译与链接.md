##编译与链接

###编译与链接过程

Xcode中Build，一键从源码到程序，其实其中隐藏了四个过程：

####1.预处理：

删除并展开对应的宏定义

处理所有的条件预编译指令：#if/#ifdef/#else/#endif

"#include/#import"包含的文件递归插入到此处。

删除所有的注释"//或/**/"。

添加行号和文件名标识。如“# 1 "main.m"”,编译调试会用到。

####2.编译

词法分析：源代码的字符序列分割成一个个token（关键字、标识符、字面量、特殊符号），比如把标识符放到符号表。

语法分析：生成抽象语法树 AST，此时运算符号的优先级确定了；有些符号具有多重含义也确定了，比如“*”是乘号还是对指针取内容；表达式不合法、括号不匹配等，都会报错。

静态分析：分析类型声明和匹配问题。比如整型和字符串相加，肯定会报错。

中间语言生成：CodeGen根据AST自顶向下遍历逐步翻译成 LLVM IR，并且在编译期就可以确定的表达式进行优化，比如代码里t1=2+6，可以优化t1=8。（假如开启了bitcode，）

目标代码生成与优化：根据中间语言生成依赖具体机器的汇编语言。并优化汇编语言。这个过程中，假如有变量且定义在同一个编译单元里，那给这个变量分配空间，确定变量的地址。假如变量或者函数不定义在这个编译单元，得链接时候，才能确定地址。

#### 3.汇编

汇编就是把上面得到的.s文件里的汇编指令一一翻译成机器指令。得到.o文件，也就是目标文件，后面会重点讲的Mach-O文件。

#### 4.连接

链接就是把目标文件（一个或多个）和需要的库（静态库/动态库）链接成可执行文件。

### 相关文件

**进程是特殊文件在内存中加载得到的结果。那这种文件的格式必须是系统内核可以理解的，系统内核才能正确解析。**而iOS和OS X支持的格式就是通用二进制文件格式和Mach-O文件格式

#### 1.通用二进制文件（胖二进制文件）

通用二进制格式就是多种架构的Mach-O文件“打包”在一起。尽管通用二进制文件会占用大量的磁盘空间，但是系统会挑选合适的Mach-O来执行，不相关的架构代码不会占用内存空间，且执行效率高了。

例如，项目中，某个SDK不支持模拟器架构，为了这个SDK导入的APP能正常使用，可以创建一个空的项目，然后编译模拟器架构（对外的方法应该一致，方法实现可以是空或者弹窗提示不支持模拟器架构）。然后在通过二进制文件命令，把两个SDK进行合并。这样这个SDK就可以正常在所有架构中使用了。

(PS：记得没错的话早期的百度地图的SDK就是分不同架构版本的，如果你要一起使用就要自己合并。)

#### 2.Mach-O文件

Mach-O目标文件是源代码编译得到的文件，那至少文件里有机器指令、数据吧。其实除了这些之外，还有链接时候需要的一些信息，比如符号表、调试信息、字符串等。然后按照不同的信息，放在不同的“段”（segment）中。机器指令一般放在代码段里，全局变量和局部静态变量一般放在数据段里。

这样分断是有不少好处的:

1.数据和指令可以被映射到不同的虚拟内存区域，可以方便的设置操作权限，比如数据区域是可读写的，而指令区域是只读的。

2.提高缓存命中率（程序的局部性），

3.系统运行多个该程序的副本时，指令是一样的，那只要保存一份指令就好了。可以节约内存。

Mach-O具体格式见格式图。

### 静态链接

静态连接：输入多个目标文件，输出一个文件（一般是可执行文件。）

首先了解两个概念：

1.模块：我们可以理解为一个源代码文件为一个模块。我们现在写程序，不可能所有代码都在一个源代码文件上，一般一个类在一个源文件上，就成为一个模块。模块化的好处就是复用、维护，还有编译时为改动的模块不需要重新编译，直接可以用缓存。

2.符号：简单理解就是函数名和变量名。

静态链接分为两个部分：

#####第一步 空间与地址分配

扫描所有的输入目标文件，并且获得他们各个段的长度、属性和位置，将输入目标文件中的符号表中所有的符号定义和符号引用收集起来（就是收集函数和变量的定义与引用），统一放到一个全局符号表。这一步中，链接器能够获得所有的输入目标文件的段的长度，将它们合并，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。（这里的合并是相似段合并，也就是说数据段与数据段合并，代码段与代码段合并）。

#####第二步 符号解析与重定位

使用上面第一步收集到的信息，读取输入文件中段的数据、重定位信息，并且进行符号解析和重定位，调整代码中的地址等。

#####如何重定位？

其实每个需要重定位的目标文件中，都有一张重定位表，专门保存这些与重定位相关的信息，可以让链接器知道模块的哪个section里的指令需要调整。

重定位就是：链接器会去查找由所有输入的目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。其中有2个常见的错误：

1. “ld: dumplicate symbols”，多个目标文件里有相同的符号，导致全局符号表出现多个一样的符号。
2. “Undefined symbols”，需要重定位的符号，在全局符号表里没有找到(一个符号：有引用，未定义)。

#### 静态库链接

**静态库可以简单的看成一组目标文件的集合，即多个目标文件经过压缩打包后形成的一个文件。**

静态库链接：是指自己的模块与静态库里某个某块（或者多个模块）链接成可执行文件。其实和静态连接一样。

(Ps:所以理论上说我们如果静态库没有都使用，是不会都链接进去的。这又间接的展示了模块化的好处，如果我们把所有函数放在一个目标文件里，但是我们又只用了一个函数，那就编译进去了很多没用的函数了)

#### 动态链接

基本思想：把程序的模块分开，不是通过静态链接在一起而是推迟到程序运行时链接在一起。

动态链接是程序主模块被加载时候，对应的Mach-O文件里有dyld加载命令，通过这个dyld然后去找依赖的dylib（Mach-O有动态链接库加载命令），把dylib加载到内存（如果对应的dylib不在内存），然后将程序中所有未决议的符号绑定到相应的 dylib中，并进行重定位工作。(其中dyld是动态链接器，dylib就是动态链接库或者共享对象)

##### position-independent code （PIC 地址无关代码）

因为dylib在编译时候是不知道自己在进程中的虚拟内存地址的，所以为了为了解决dylib的代码段能被共享，PIC（地址无关代码）技术就产生了。PIC原理很简单，就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分是每个进程都有一个副本。

###### 相对寻址

由于调用者和被调用者都在同一个模块里，它们之间的相对位置不变。于是有了相对寻址，用相对寻址就可以做到是地址无关代码。

1.模块内部的函数调用2.模块内部的数据访问（数据相对指令的相对位置也是固定的）。

###### 间接寻址

把跟地址相关的部分放到数据段里面。mach-o文件的数据段有一个got section（got：Global Offset Table 全局偏移表），当代码需要引用该全局变量时，可以通过got中相对应的项间接引用。链接器在装载模块时候会查找每个外部变量所在的地址，然后填充got中的各个项，确保got里面存放的地址是正确的。got在数据段，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。

1.模块外部的数据访问

2.模块外部的函数调用、跳转等。

上面有又有个重要的思想：延迟绑定。
延迟绑定基本思想跟iOS的objc_msgSend基本一样的，都是第一次调用函数时候，去查找函数的地址。而不是程序启动时候，先把所有地址查找好。（got在数据段，程序运行期间可修改，所以第一次调用后，把函数的真实地址填入即可。objc_msgSend是第一次调用后，把函数地址放入cache里，加速查找。）

####fishhook原理

模块间的数据访问和函数调用，都是用间接寻址。主模块将要访问动态库里的数据符号地址放在got(也称Non-Lazy Symbol Pointers)数据段，调用动态库的函数的地址放在la_symbol_ptr数据段。而数据段是可读写的，所以程序运行期间我们可以通过修改got(nl_symbol_ptr)和la_symbol_ptr数据段，来替换函数跟全局变量的地址。这个就是fishhook的原理。

所以fishhook 是hook动态库的函数或者变量的。

参考：[iOS程序员的自我修养](https://juejin.im/post/5d527302f265da039d32c246)

